package testutil

import (
	"bytes"
	"crypto/md5"
	"encoding/hex"
	"errors"
	"fmt"
	"os"
	"testing"

	"github.com/alextanhongpin/core/internal"
	"github.com/alextanhongpin/core/test/testdump"
	"github.com/google/go-cmp/cmp"
	"golang.org/x/tools/txtar"
)

// Those with x is shared.
type FileName string

func (x FileName) isJSON() {}
func (x FileName) isYAML() {}
func (x FileName) isSQL()  {}
func (x FileName) isGRPC() {}
func (x FileName) isHTTP() {}
func (x FileName) isText() {}

type CmpOption []cmp.Option

func (x CmpOption) isJSON() {}
func (x CmpOption) isYAML() {}

func CmpOpts(opts ...cmp.Option) CmpOption {
	return CmpOption(opts)
}

type ignoreFields []string

func (ignoreFields) isJSON() {}
func (ignoreFields) isYAML() {}

func IgnoreFields(fields ...string) ignoreFields {
	return ignoreFields(fields)
}

type maskFields []string

func (maskFields) isJSON() {}
func (maskFields) isYAML() {}

func MaskFields(fields ...string) maskFields {
	return maskFields(fields)
}

type Dumper struct {
	name string
	t    *testing.T
	i    int
	arc  *txtar.Archive
	seen map[string]int
	err  error
}

func New(t *testing.T) *Dumper {
	p := Path{
		Dir:      "testdata",
		FilePath: t.Name(),
		FileExt:  ".txtar",
	}
	arc, err := txtar.ParseFile(p.String())
	if err != nil && !errors.Is(err, os.ErrNotExist) {
		panic(err)
	}
	if arc == nil {
		arc = new(txtar.Archive)
		arc.Comment = []byte(t.Name())
	}
	d := &Dumper{
		name: p.String(),
		t:    t,
		arc:  arc,
		seen: make(map[string]int),
	}
	ori := len(d.arc.Files)
	t.Cleanup(func() {
		update := d.i != len(d.arc.Files) || d.i != ori
		update = update && d.err == nil
		fmt.Println(d.err, "is not nil")
		d.arc.Files = d.arc.Files[:d.i] // Handle deletion.
		internal.WriteFile(p.String(), txtar.Format(d.arc), update)
	})
	return d
}

func (d *Dumper) DumpJSON(v any, opts ...JSONOption) {
	t := d.t
	t.Helper()
	d.i++

	o := newJSONOption(opts...)

	var fileName string
	for _, opt := range opts {
		switch v := opt.(type) {
		case FileName:
			fileName = string(v)
		}
	}

	p := Path{
		FileName: internal.Or(fileName, internal.TypeName(v)),
		FileExt:  ".json",
	}

	d.seen[p.String()]++
	if n := d.seen[p.String()]; n > 1 {
		p.FileName += fmt.Sprint(n - 1)
	}

	if err := testdump.JSON(&txtarDumper{i: d.i, arc: d.arc, name: p.String()}, v, o); err != nil {
		d.err = err
		t.Fatalf("\n  %s\n  -- %s --%s", d.name, p.String(), err)
	}
}

func (d *Dumper) DumpYAML(v any, opts ...YAMLOption) {
	t := d.t
	t.Helper()
	d.i++

	o := newYAMLOption(opts...)

	var fileName string
	for _, opt := range opts {
		switch v := opt.(type) {
		case FileName:
			fileName = string(v)
		}
	}

	p := Path{
		FileName: internal.Or(fileName, internal.TypeName(v)),
		FileExt:  ".yaml",
	}

	d.seen[p.String()]++
	if n := d.seen[p.String()]; n > 1 {
		p.FileName += fmt.Sprint(n - 1)
	}

	if err := testdump.YAML(&txtarDumper{i: d.i, arc: d.arc, name: p.String()}, v, o); err != nil {
		d.err = err
		t.Fatalf("\n  %s\n  -- %s --%s", d.name, p.String(), err)
	}
}

func (d *Dumper) DumpText(s string, opts ...TextOption) {
	t := d.t
	t.Helper()
	d.i++

	var fileName string
	for _, opt := range opts {
		switch v := opt.(type) {
		case FileName:
			fileName = string(v)
		}
	}
	if fileName == "" {
		h := md5.New()
		h.Write([]byte(s))
		fileName = hex.EncodeToString(h.Sum(nil))
	}

	p := Path{
		FileName: fileName,
		FileExt:  ".txt",
	}

	d.seen[p.String()]++
	if n := d.seen[p.String()]; n > 1 {
		p.FileName += fmt.Sprint(n - 1)
	}

	if err := testdump.Text(&txtarDumper{i: d.i, arc: d.arc, name: p.String()}, s); err != nil {
		d.err = err
		t.Fatalf("\n  %s\n  -- %s --%s", d.name, p.String(), err)
	}
}

type txtarDumper struct {
	i    int
	name string
	arc  *txtar.Archive
}

func (d *txtarDumper) Write(data []byte) error {
	if len(d.arc.Files) < d.i {
		d.arc.Files = append(d.arc.Files, txtar.File{
			Name: d.name,
			Data: data,
		})
	}

	return nil
}

func (d *txtarDumper) Read() ([]byte, error) {
	if len(d.arc.Files) < d.i {
		return nil, nil
	}

	f := d.arc.Files[d.i-1]
	if f.Name != d.name {
		return nil, fmt.Errorf("\n  filename mismatch: %s", internal.ANSIDiff(f.Name, d.name))
	}
	// Clear the newline generated by txtar.
	return bytes.TrimSpace(f.Data), nil
}
